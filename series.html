<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Series - Cat√°logo</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="var(--primary-bg)">
  <link rel="stylesheet" href="style.css"> <!-- Ensure this is present -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script>
    // PWA: registrar service worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js');
      });
    }
  </script>
  <!-- Minimal inline styles from previous step are removed as they should be in style.css -->
</head>
<body>

  <header class="page-subheader">
    <div class="page-container">
      <h1>üì∫ Series Populares</h1>
      <nav>
        <a href="dash.html" class="btn btn-secondary">Volver al Hub</a>
        <button id="logout-btn" class="btn btn-secondary" style="margin-left: 0.5rem;">Cerrar sesi√≥n</button>
      </nav>
    </div>
  </header>

  <main class="page-container">
    <div class="filters-toolbar">
      <input type="text" id="search-input" placeholder="Buscar series..." aria-label="Buscar series por t√≠tulo" />
      <select id="genre-select" aria-label="Filtrar por g√©nero">
        <option value="0">Todos los g√©neros</option>
        <!-- Genres will be populated by JS -->
      </select>
      <select id="sort-select" aria-label="Ordenar por">
        <option value="popularity.desc">M√°s populares</option>
        <option value="popularity.asc">Menos populares</option>
        <option value="first_air_date.desc">M√°s nuevas</option>
        <option value="first_air_date.asc">M√°s antiguas</option>
        <option value="vote_average.desc">Mejor puntuadas</option>
        <option value="vote_average.asc">Peor puntuadas</option>
        <option value="original_name.asc">T√≠tulo (A-Z)</option>
        <option value="original_name.desc">T√≠tulo (Z-A)</option>
      </select>
    </div>

    <div class="media-grid-container" id="series-container">
      <p class="text-muted" style="text-align:center; grid-column: 1 / -1;">Cargando series...</p>
    </div>

    <div class="pagination">
      <button id="prev-page" class="btn" disabled>Anterior</button>
      <span id="page-indicator" class="page-indicator">P√°gina 1</span>
      <button id="next-page" class="btn">Siguiente</button>
    </div>

    <div id="serie-modal" class="modal"> <!-- JS controls 'active' class -->
      <div class="modal-content" tabindex="0">
        <button class="modal-close" id="serie-modal-close-btn" aria-label="Cerrar modal">&times;</button>
        <div id="serie-modal-body"></div>
      </div>
    </div>
  </main>

  <footer class="page-footer">
     <div class="page-container">
      <p>¬© 2024 Cat√°logo Cine & Series. Todos los derechos reservados.</p>
    </div>
  </footer>

  <div id="toast-container" aria-live="polite" aria-atomic="true"></div>

  <script>
    const API_KEY = '83d8f9fcd910cdb387149196e65e6afd'; // Keep this secure
    const BASE_URL = 'https://api.themoviedb.org/3';
    const IMG_URL = 'https://image.tmdb.org/t/p/w500';

    let currentPage = 1;
    let totalPages = 1;
    let currentGenre = "0";
    let currentSearchQuery = '';
    let currentSort = 'popularity.desc';
    let series = []; // Holds the current list of series
    let genres = [];

    const genreSelect = document.getElementById('genre-select');
    const sortSelect = document.getElementById('sort-select');
    const seriesContainer = document.getElementById('series-container');
    const searchInput = document.getElementById('search-input');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const pageIndicator = document.getElementById('page-indicator');
    const logoutBtn = document.getElementById('logout-btn');

    const token = localStorage.getItem('jwt');
    const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));

    if (!token || !loggedInUser || !loggedInUser.id) {
      alert('Usuario no autenticado. Redirigiendo a login.');
      window.location.href = 'login.html';
    }

    if(logoutBtn) {
        logoutBtn.addEventListener('click', async () => {
            if (confirm("¬øSeguro que quieres cerrar sesi√≥n?")) {
                if (token) {
                    try {
                        await fetch('http://localhost:3001/logout', {
                            method: 'POST', headers: { 'Authorization': `Bearer ${token}` }
                        });
                    } catch (e) { console.warn('Logout API call failed', e); }
                }
                localStorage.removeItem('loggedInUser');
                localStorage.removeItem('jwt');
                localStorage.removeItem('adminToken');
                window.location.href = 'index.html';
            }
        });
    }

    let favoritosSeriesIds = new Set();
    let guardadosSeriesIds = new Set();

    async function fetchUserLists() {
        const userId = loggedInUser.id;
        try {
            const [favRes, savedRes] = await Promise.all([
                safeFetch(`http://localhost:3001/favoritos?user_id=${userId}`), // Endpoint for series favorites
                safeFetch(`http://localhost:3001/guardados?user_id=${userId}`)  // Endpoint for series saved
            ]);
            if (favRes) {
                favoritosSeriesIds = new Set(favRes.map(s => s.id));
            }
            if (savedRes) {
                guardadosSeriesIds = new Set(savedRes.map(s => s.id));
            }
        } catch (e) {
            console.error("Error fetching user lists for series:", e);
            showToast('Error al cargar listas de usuario.', 'error');
        }
    }

    function renderSeries() {
      seriesContainer.innerHTML = '';
      if (series.length === 0) {
        seriesContainer.innerHTML = '<p class="text-muted" style="text-align:center; grid-column: 1 / -1;">No se encontraron series que coincidan con tus criterios.</p>';
        return;
      }

      series.forEach(item => {
        const itemType = 'tv';
        const title = item.name;
        const posterPath = item.poster_path ? `${IMG_URL}${item.poster_path}` : 'https://via.placeholder.com/500x750.png?text=No+Image';
        const year = item.first_air_date ? item.first_air_date.substring(0, 4) : 'N/A';
        const rating = item.vote_average ? item.vote_average.toFixed(1) : 'N/A';
        const description = item.overview || '';
        const shortDescription = description.length > 80 ? description.substring(0, 80) + '...' : description;

        const isFavorite = favoritosSeriesIds.has(item.id);
        const isSaved = guardadosSeriesIds.has(item.id);

        const cardHTML = `
            <div class="media-card" data-id="${item.id}" data-type="${itemType}">
                <img src="${posterPath}" alt="${title}" class="media-card-poster" onerror="this.onerror=null;this.src='https://via.placeholder.com/500x750.png?text=No+Image';">
                <div class="media-card-body">
                    <h3 class="media-card-title">${title}</h3>
                    <p class="media-card-info">${year} | Rating: ${rating}</p>
                    <p class="media-card-overview">${shortDescription}</p>
                    <div class="media-card-actions">
                        <button class="btn btn-favorite ${isFavorite ? 'active' : ''}" data-action="toggleFavorite">
                            <i class="material-icons">${isFavorite ? 'favorite' : 'favorite_border'}</i> Favorito
                        </button>
                        <button class="btn btn-save ${isSaved ? 'active' : ''}" data-action="toggleSave">
                            <i class="material-icons">${isSaved ? 'bookmark' : 'bookmark_border'}</i> Guardar
                        </button>
                        <button class="btn btn-details" data-action="showDetails">
                            <i class="material-icons">info</i> Detalles
                        </button>
                    </div>
                </div>
            </div>
        `;
        seriesContainer.insertAdjacentHTML('beforeend', cardHTML);
      });
    }

    seriesContainer.addEventListener('click', function(event) {
        const button = event.target.closest('button.btn');
        if (button) {
            const card = button.closest('.media-card');
            if (!card) return;

            const itemId = parseInt(card.dataset.id);
            const itemType = card.dataset.type; // Should be 'tv'
            const action = button.dataset.action;

            if (action === 'toggleFavorite') {
                toggleFavorito(itemId, button);
            } else if (action === 'toggleSave') {
                toggleGuardado(itemId, button);
            } else if (action === 'showDetails') {
                openSerieModal(itemId);
            }
        } else {
             const cardDetails = event.target.closest('.media-card');
             if (cardDetails) { // Check if the click was on the card itself, not outside
                const itemId = parseInt(cardDetails.dataset.id);
                openSerieModal(itemId);
             }
        }
    });

    async function toggleFavorito(serieId, buttonElement) {
        const isCurrentlyFavorite = favoritosSeriesIds.has(serieId);
        const method = isCurrentlyFavorite ? 'DELETE' : 'POST';
        const serieObject = series.find(s => s.id === serieId);

        if (!serieObject) { showToast('Error: Serie no encontrada.', 'error'); return; }

        try {
            const res = await safeFetch('http://localhost:3001/favoritos', {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: loggedInUser.id, serie_id: serieId, serie: method === 'POST' ? serieObject : undefined })
            });
            if (res.ok !== false) {
                if (isCurrentlyFavorite) {
                    favoritosSeriesIds.delete(serieId);
                    buttonElement.classList.remove('active');
                    buttonElement.querySelector('.material-icons').textContent = 'favorite_border';
                } else {
                    favoritosSeriesIds.add(serieId);
                    buttonElement.classList.add('active');
                    buttonElement.querySelector('.material-icons').textContent = 'favorite';
                }
                showToast(`Favorito ${isCurrentlyFavorite ? 'eliminado' : 'agregado'}: "${serieObject.name}"`, isCurrentlyFavorite ? 'fail' : 'success');
            } else { showToast('Error al actualizar favoritos.', 'error');}
        } catch (e) { /* safeFetch handles toast */ }
    }

    async function toggleGuardado(serieId, buttonElement) {
        const isCurrentlySaved = guardadosSeriesIds.has(serieId);
        const method = isCurrentlySaved ? 'DELETE' : 'POST';
        const serieObject = series.find(s => s.id === serieId);

        if (!serieObject) { showToast('Error: Serie no encontrada.', 'error'); return; }

        try {
            const res = await safeFetch('http://localhost:3001/guardados', {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: loggedInUser.id, serie_id: serieId, serie: method === 'POST' ? serieObject : undefined })
            });
            if (res.ok !== false) {
                if (isCurrentlySaved) {
                    guardadosSeriesIds.delete(serieId);
                    buttonElement.classList.remove('active');
                    buttonElement.querySelector('.material-icons').textContent = 'bookmark_border';
                } else {
                    guardadosSeriesIds.add(serieId);
                    buttonElement.classList.add('active');
                    buttonElement.querySelector('.material-icons').textContent = 'bookmark';
                }
                showToast(`Serie ${isCurrentlySaved ? 'eliminada de' : 'guardada en'} "Ver m√°s tarde": "${serieObject.name}"`, isCurrentlySaved ? 'fail' : 'success');
            } else { showToast('Error al actualizar guardados.', 'error');}
        } catch (e) { /* safeFetch handles toast */ }
    }

    async function fetchSeriesFromTMDB() {
      seriesContainer.innerHTML = '<p class="text-muted" style="text-align:center; grid-column: 1 / -1;">Cargando...</p>';
      let url;
      const genreQueryParam = currentGenre === "0" ? '' : `&with_genres=${currentGenre}`;
      if (currentSearchQuery) {
        url = `${BASE_URL}/search/tv?api_key=${API_KEY}&language=es-ES&query=${encodeURIComponent(currentSearchQuery)}&page=${currentPage}&include_adult=false`;
      } else {
        url = `${BASE_URL}/discover/tv?api_key=${API_KEY}&language=es-ES&sort_by=${currentSort}&page=${currentPage}${genreQueryParam}&include_adult=false&vote_count.gte=50`;
      }

      try {
        const res = await fetch(url); // Using global fetch, not safeFetch for TMDB
        if (!res.ok) throw new Error(`Error ${res.status} fetching from TMDB: ${res.statusText}`);
        const data = await res.json();
        series = data.results || [];
        totalPages = data.total_pages > 500 ? 500 : (data.total_pages || 1);

        // Fetch user lists before rendering cards
        // await fetchUserLists(); // Called once at DOMContentLoaded now
        renderSeries();
        updatePaginationControls();
      } catch (e) {
        console.error('Error cargando series:', e);
        seriesContainer.innerHTML = '<p class="text-muted" style="text-align:center; grid-column: 1 / -1; color:var(--accent-color);">Error al cargar series. Intenta de nuevo m√°s tarde.</p>';
        showToast('Error al cargar series de TMDB.', 'error');
      }
    }

    async function fetchTvGenres() { // Renamed to avoid conflict if peliculas.js is ever merged/imported
      try {
        const res = await fetch(`${BASE_URL}/genre/tv/list?api_key=${API_KEY}&language=es-ES`);
        if (!res.ok) throw new Error('Failed to fetch TV genres');
        const data = await res.json();
        genres = data.genres || []; // Assuming 'genres' is the correct global variable for this page
        populateGenreSelect();
      } catch (e) {
        console.error('Error cargando g√©neros de TV:', e);
        showToast('Error al cargar g√©neros de TV.', 'error');
      }
    }

    function populateGenreSelect() {
      genreSelect.innerHTML = '<option value="0">Todos los g√©neros</option>'; // Clear previous before populating
      genres.forEach(genre => {
        const option = document.createElement('option');
        option.value = genre.id;
        option.textContent = genre.name;
        genreSelect.appendChild(option);
      });
    }

    function updatePaginationControls() {
      pageIndicator.textContent = `P√°gina ${currentPage} de ${totalPages}`;
      prevPageBtn.disabled = currentPage <= 1;
      nextPageBtn.disabled = currentPage >= totalPages;
    }

    let debounceTimeout;
    searchInput.addEventListener('input', () => {
      clearTimeout(debounceTimeout);
      debounceTimeout = setTimeout(() => {
        currentSearchQuery = searchInput.value.trim();
        currentPage = 1;
        fetchSeriesFromTMDB();
      }, 500);
    });
    genreSelect.addEventListener('change', (e) => {
      currentGenre = e.target.value; currentPage = 1; fetchSeriesFromTMDB();
    });
    sortSelect.addEventListener('change', (e) => {
      currentSort = e.target.value; currentPage = 1; fetchSeriesFromTMDB();
    });
    prevPageBtn.addEventListener('click', () => { if (currentPage > 1) { currentPage--; fetchSeriesFromTMDB(); } });
    nextPageBtn.addEventListener('click', () => { if (currentPage < totalPages) { currentPage++; fetchSeriesFromTMDB(); } });

    const modal = document.getElementById('serie-modal'); // Corrected ID from HTML
    const modalBody = document.getElementById('serie-modal-body');
    const modalCloseBtn = document.getElementById('serie-modal-close-btn');

    function openSerieModal(serieId) {
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
      showSerieDetails(serieId);
    }
    function closeSerieModal() {
      modal.classList.remove('active');
      document.body.style.overflow = '';
      modalBody.innerHTML = '';
    }
    if(modalCloseBtn) modalCloseBtn.addEventListener('click', closeSerieModal);
    if(modal) modal.addEventListener('click', (e) => { if (e.target === modal) closeSerieModal(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && modal.classList.contains('active')) closeSerieModal(); });

    async function showSerieDetails(serieId) {
        modalBody.innerHTML = '<p class="text-muted" style="text-align:center;">Cargando detalles...</p>';
        try {
            const res = await fetch(`${BASE_URL}/tv/${serieId}?api_key=${API_KEY}&language=es-ES&append_to_response=videos,reviews,credits`);
            if(!res.ok) {
                modalBody.innerHTML = '<p style="color:var(--accent-color); text-align:center;">Error al cargar detalles.</p>';
                return;
            }
            const details = await res.json();
            const trailer = details.videos?.results?.find(v => v.site === 'YouTube' && v.type === 'Trailer');
            const director = details.credits?.crew?.find(c => c.job === 'Director' || c.department === 'Directing') || details.created_by?.[0];
            const cast = details.credits?.cast?.slice(0, 5).map(a => a.name).join(', ');

            modalBody.innerHTML = `
                <h2 style="color: var(--accent-color); margin-bottom: 1rem;">${details.name} (${(details.first_air_date || '').substring(0,4)})</h2>
                <p style="margin-bottom: 1rem;">${details.overview}</p>
                <p><strong>Rating:</strong> ${details.vote_average ? details.vote_average.toFixed(1) : 'N/A'}/10 (${details.vote_count} votos)</p>
                <p><strong>G√©neros:</strong> ${details.genres?.map(g => g.name).join(', ') || 'N/A'}</p>
                <p><strong>${director?.job === 'Director' ? 'Director' : 'Creador(a)'}:</strong> ${director ? director.name : 'N/A'}</p>
                <p><strong>Reparto Principal:</strong> ${cast || 'N/A'}</p>
                <p><strong>Temporadas:</strong> ${details.number_of_seasons || 'N/A'} | <strong>Episodios:</strong> ${details.number_of_episodes || 'N/A'}</p>
                ${trailer ? `<div style="margin-top:1rem; margin-bottom:1rem; position:relative; padding-bottom:56.25%; height:0; overflow:hidden;"><iframe style="position:absolute; top:0; left:0; width:100%; height:100%;" src="https://www.youtube.com/embed/${trailer.key}" frameborder="0" allowfullscreen></iframe></div>` : '<p style="margin-top:1rem;">No hay trailer disponible.</p>'}
            `;
        } catch (e) {
            modalBody.innerHTML = '<p style="color:var(--accent-color); text-align:center;">Error al cargar detalles.</p>';
        }
    }

    function showToast(message, type = 'info', duration = 3000) {
        const container = document.getElementById('toast-container');
        if (!container) {
            console.warn("Toast container not found!");
            return;
        }
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        container.appendChild(toast);

        toast.style.animation = 'slideInToast 0.4s forwards'; // Ensure slideIn is applied
        setTimeout(() => {
            toast.style.animation = 'fadeOutToast 0.4s forwards';
            toast.addEventListener('animationend', (e) => {
                if (e.animationName === 'fadeOutToast') { // Make sure it's the fadeOut animation
                    toast.remove();
                }
            }, { once: true });
        }, duration);
    }

    // SafeFetch (already defined in peliculas.html, ensure consistency or share via global script)
    async function safeFetch(url, options = {}) {
      options.headers = options.headers || {};
      if (url.startsWith('http://localhost:3001')) {
        options.headers['Authorization'] = `Bearer ${token}`;
      }
      try {
        const res = await fetch(url, options);
        if (!res.ok) {
          let errMsg = `Error ${res.status}`;
          try {
            const data = await res.json();
            errMsg = data.error || errMsg;
          } catch {}
          throw new Error(errMsg);
        }
        return await res.json();
      } catch (err) {
        showToast(err.message || 'Error de conexi√≥n con el servidor.', 'error');
        throw err;
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await fetchUserLists(); // Fetch user's favorite/saved series IDs first
      await fetchTvGenres();
      await fetchSeriesFromTMDB();
    });
  </script>

</body>
</html>
